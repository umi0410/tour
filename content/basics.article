패키지와 변수, 함수
모든 Go 프로그램의 기본 구성요소들에 대해 배워보십시오.

The Go Authors
https://golang.org

* 패키지

모든 Go 프로그램은 패키지로 구성되어있습니다.

Programs start running in package `main`.

This program is using the packages with import paths `"fmt"` and `"math/rand"`.

By convention, the package name is the same as the last element of the import path. For instance, the `"math/rand"` package comprises files that begin with the statement `package`rand`.

#appengine: *Note:* The environment in which these programs are executed is
#appengine: deterministic, so each time you run the example program
#appengine: `rand.Intn` will return the same number.
#appengine:
#appengine: (To see a different number, seed the number generator; see [[https://golang.org/pkg/math/rand/#Seed][`rand.Seed`]].
#appengine: Time is constant in the playground, so you will need to use something else as the seed.)

.play basics/packages.go

* Imports

This code groups the imports into a parenthesized, "factored" import statement.

You can also write multiple import statements, like:

	import "fmt"
	import "math"

But it is good style to use the factored import statement.

.play basics/imports.go

* Exported names

In Go, a name is exported if it begins with a capital letter.
For example, `Pizza` is an exported name, as is `Pi`, which is exported from
the `math` package.

`pizza` and `pi` do not start with a capital letter, so they are not exported.

When importing a package, you can refer only to its exported names.
Any "unexported" names are not accessible from outside the package.

Run the code. Notice the error message.

To fix the error, rename `math.pi` to `math.Pi` and try it again.

.play basics/exported-names.go

* Functions

A function can take zero or more arguments.

In this example, `add` takes two parameters of type `int`.

Notice that the type comes _after_ the variable name.

(For more about why types look the way they do, see the [[https://blog.golang.org/gos-declaration-syntax][article on Go's declaration syntax]].)

.play basics/functions.go

* Functions continued

When two or more consecutive named function parameters share a type, you can omit the type from all but the last.

In this example, we shortened

	x int, y int

to

	x, y int

.play basics/functions-continued.go

* Multiple results

A function can return any number of results.

The `swap` function returns two strings.

.play basics/multiple-results.go

* Named return values

Go's return values may be named. If so, they are treated as variables defined at the top of the function.

These names should be used to document the meaning of the return values.

A `return` statement without arguments returns the named return values. This is known as a "naked" return.

Naked return statements should be used only in short functions, as with the example shown here. They can harm readability in longer functions.

.play basics/named-results.go

* Variables

The `var` statement declares a list of variables; as in function argument lists, the type is last.

A `var` statement can be at package or function level. We see both in this example.

.play basics/variables.go

* Variables with initializers

A var declaration can include initializers, one per variable.

If an initializer is present, the type can be omitted; the variable will take the type of the initializer.

.play basics/variables-with-initializers.go

* Short variable declarations

Inside a function, the `:=` short assignment statement can be used in place of a `var` declaration with implicit type.

Outside a function, every statement begins with a keyword (`var`, `func`, and so on) and so the `:=` construct is not available.

.play basics/short-variable-declarations.go

* 기본 자료형

고의 기본 type들은 다음과 같습니다.

    bool

    string

    int  int8  int16  int32  int64
    uint uint8 uint16 uint32 uint64 uintptr

    byte // uint8의 별칭

    rune // int32의 별칭
         // 유니코드에서 code point를 의미합니다.

    float32 float64

    complex64 complex128

이 예시는 몇 가지 type의 변수를 보여줄 것이고, 그 변수 선언들은 import 문과 마찬가지로 조각으로 쪼개질 수 있습니다.

`int` 와 `uintptr` type은 보통 32-bit 시스템에서는 32 bit, 64-bit 시스템에서는 64 bit의 길이입니다.
정수 값이 필요할 때에는 특정한 이유로 크기를 정해야하거나 unsigned 정수 type을 사용해야하는 게 아니라면 `int` 를 사용해야합니다.

.play basics/basic-types.go

* Zero values

명시적인 초깃값 없이 선언된 변수는 그것의 _zero_value_가 주어집니다.

`zero value` 는 다음과 같습니다.

- 숫자 type에는 0
- boolean type에는 false
- string에는 "" (빈 문자열)

* Type 변환

`T(v)` 는 `v` 라는 값을 T type으로 변환시켜줍니다.

몇 가지 숫자 변환 예시:

    var i int = 42
    var f float64 = float64(i)
    var u uint = uint(f)

혹은 좀 더 간단히:

    i := 42
    f := float64(i)
    u := uint(f)

C와 달리 Go는 다른 type의 요소들 간의 할당에는 명시적인 변환을 필요로합니다.
예시에서 `float64` 나 `uint` 변환을 제거해보시고, 어떤 일이 발생하는 지 보십시오.

.play basics/type-conversions.go

* Inference type

`:=` 혹은 `var =` 표현을 이용해 명시적인 type을 정의하지 않고 변수를 선언할 때, 그 변수 type은 오른 편에 있는 값으로부터 유추됩니다.

변수 선언의 오른 쪽에 무언가 적힐 때, 새로운 변수는 그것과 같은 type이 됩니다.

    var i int
    j := i // j 는 int

하지만, 오른 편에 type이 정해지지 않은 숫자 상수가 올 때, 새 변수는 그 상수의 정확도에 따라 `int` 혹은 `float64`, `complex128` 이 됩니다.

    i := 42           // int
    f := 3.142        // float64
    g := 0.867 + 0.5i // complex128

예시에서 `v` 의 초깃값을 바꿔보시고 `v` 의 type에 어떤 영향을 끼치는 지 보십시오.

.play basics/type-inference.go

* 상수

상수는 변수처럼 선언되지만 `const` 키워드와 함께 선언됩니다.

상수는 `character` 혹은 `string`, `boolean`, 숫자 값이 될 수 있습니다.

상수는 `:=` 를 통해 선언될 수 없습니다.

.play basics/constants.go

* Numeric Constants

숫자형 상수
숫자형 상수는 매우 정확한 _값_입니다.

type이 정해지지 않은 상수는 그것의 문맥에서 필요한 type을 취합니다.

`needInt(Big)`` 을 출력해보세요.

(`int` 는 최대 64-bit 혹은 때때로 더 작은 정수를 저장할 수 있습니다.)

.play basics/numeric-constants.go

* Congratulations!
축하드립니다!
당신은 이번 강의를 마쳤습니다!

다음에 무엇을 배울 지 보러 [[/list][단원]]의 목록으로 돌아가실 수도 있고, [[javascript:click('.next-page')][다음]]으로 강의를 이어가실 수도 있습니다.
